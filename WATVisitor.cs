/*
  Hydra compiler - WebAssembly text file (WAT) code generator.
  Copyright (C) 2013-2020 Ariel Ortiz, ITESM CEM,
  Modified by: Gerardo Galván, Jesús Perea, Jorge López.

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.Text;

namespace Hydra_compiler {

  class WATVisitor {

    public GlobalVariables GlobalVariables {
      get;
      private set;
    }
    public GlobalFunctions GlobalFunctions {
      get;
      private set;
    }
    public LocalSymbolTable TempLocalSymbolTable {
      get;
      private set;
    }
    string tempValueAssignment = "";
    bool inVariableDefinition = false;
    bool inStatement = false;
    int labelCounter = 0;

    public WATVisitor (GlobalVariables globalVariables, GlobalFunctions globalFunctions) {
      this.GlobalFunctions = globalFunctions;
      this.GlobalVariables = globalVariables;
    }
    public string Generatelabel () {
      return $"${labelCounter++:00000}";
    }
    public IList<int> AsCodePoint (String str) {
      var result = new List<int> (str.Length);
      for (int i = 0; i < str.Length; i++) {
        result.Add (char.ConvertToUtf32 (str, i));
        if (char.IsHighSurrogate (str, i)) {
          i++;
        }
      }
      return result;
    }
    public string ImportAPI () {
      string funcionImport = "";
      foreach (var function in GlobalFunctions) {
        if (function.Value.isPrimitive) {
          funcionImport += $"  (import \"hydra\" \"{function.Key}\" (func ${function.Key} ";
          for (int i = 0; i < function.Value.arity; i++) {
            funcionImport += "(param i32) ";
          }
          funcionImport += "(result i32)))\n";
        }
      }
      return funcionImport;
    }
    public string ImportGlobals () {
      StringBuilder sb = new StringBuilder ();
      foreach (var varName in GlobalVariables) {
        sb.Append ($"\t(global ${varName.name} (import \"globals\" \"{varName.name}\") (mut i32))\n");
      }
      return sb.ToString ();
    }

    //-----------------------------------------------------------
    public string Visit (Program node) {
      return ";; WebAssembly text format code generated by " +
        "the hydra compiler.\n\n" +
        "(module\n" +
        ImportAPI () +
        ImportGlobals () +
        VisitChildren (node) +
        ")\n";
    }
    //-----------------------------------------------------------
    public string Visit (DefinitionList node) {
      return VisitChildren (node);
    }
    //-----------------------------------------------------------
    public string Visit (VariableDefinitionList node) {
      inVariableDefinition = true;
      var result = VisitChildren (node);
      result += tempValueAssignment;
      tempValueAssignment = "";
      inVariableDefinition = false;
      return result;
    }
    //-----------------------------------------------------------
    public string Visit (FunctionDefinition node) {
      var functionName = node.AnchorToken.Lexeme;
      StringBuilder sb = new StringBuilder ();
      this.TempLocalSymbolTable = GlobalFunctions[functionName].RefST;
      if (functionName == "main") {
        sb.Append ($"  (func (export \"{functionName}\") ");
      } else {
        sb.Append ($"  (func ${functionName} ");
      }
      sb.Append (VisitChildren (node));
      sb.Append ("\t\ti32.const 0\n\t)\n");
      this.TempLocalSymbolTable = null;
      return sb.ToString ();
    }
    //-----------------------------------------------------------
    public string Visit (IdParameterList node) {
      StringBuilder sb = new StringBuilder ();
      foreach (var param in TempLocalSymbolTable) {
        if (param.Value) {
          sb.Append ($"(param ${param.Key} i32) ");
        }
      }
      sb.Append ("\n\t\t(result i32)\n");
      return sb.ToString ();
    }
    //-----------------------------------------------------------
    public string Visit (StatementList node) {
      inStatement = true;
      var str = VisitChildren (node);
      inStatement = false;
      return str;
    }
    //-----------------------------------------------------------
    public string Visit (Assignment node) {
      var varName = node.AnchorToken.Lexeme;
      if (inVariableDefinition) {
        if (TempLocalSymbolTable != null && TempLocalSymbolTable.Contains (varName)) {
          //I'm creating a new local variable
          //and assigning a value to that local variable
          tempValueAssignment += Visit ((dynamic) node[0]);
          tempValueAssignment += $"    local.set ${varName}\n";
          return $"    (local ${varName} i32)\n";
        } else {
          //I'm creating a new global variable
          //and assigning a value to that global variable
          //But that logic it was already proccesed
          return "";
        }
      } else {
        if (TempLocalSymbolTable.Contains (varName)) {
          //I'm ssigning a value to local variable
          return Visit ((dynamic) node[0]) +
            $"\t\tlocal.set ${varName}\n";
        } else {
          //I'm assigning a value to a global variable
          return Visit ((dynamic) node[0]) +
            $"\t\tglobal.set ${varName}\n";
        }
      }
    }
    //-----------------------------------------------------------
    public string Visit (PlusPlus node) {
      var str = "\t\ti32.const 1\n" +
        Visit ((dynamic) node[0]) +
        "\t\ti32.add\n";
      var varName = node[0].AnchorToken.Lexeme;
      if (TempLocalSymbolTable.Contains (varName)) {
        str += $"\t\tlocal.set ${varName}\n";
      } else {
        str += $"\t\tglobal.set ${varName}\n";
      }

      return str;
    }
    //-----------------------------------------------------------
    public string Visit (LessLess node) {
      var str = "\t\ti32.const 1\n" +
        Visit ((dynamic) node[0]) +
        "\t\ti32.sub\n";
      var varName = node[0].AnchorToken.Lexeme;
      if (TempLocalSymbolTable.Contains (varName)) {
        str += $"\t\tlocal.set ${varName}\n";
      } else {
        str += $"\t\tglobal.set ${varName}\n";
      }

      return str;
    }
    //-----------------------------------------------------------
    public string Visit (PlusEqual node){
      var str = Visit((dynamic) node[0]);
      str += Visit((dynamic) node[1]);
      var varName = node[0].AnchorToken.Lexeme;
      str += "\t\ti32.add\n";
      if (TempLocalSymbolTable.Contains (varName)) {
        str += $"\t\tlocal.set ${varName}\n";
      } else {
        str += $"\t\tglobal.set ${varName}\n";
      }
      return str;
    }
    //-----------------------------------------------------------
    public string Visit (SubtracEqual node){
      var str = Visit((dynamic) node[0]);
      str += Visit((dynamic) node[1]);
      var varName = node[0].AnchorToken.Lexeme;
      str += "\t\ti32.sub\n";
      if (TempLocalSymbolTable.Contains (varName)) {
        str += $"\t\tlocal.set ${varName}\n";
      } else {
        str += $"\t\tglobal.set ${varName}\n";
      }
      return str;
    }
    //-----------------------------------------------------------
    public string Visit (FunctionCall node) {
      var str = VisitChildren (node);
      str += $"\t\tcall ${node.AnchorToken.Lexeme}\n";
      return str;
    }
    //-----------------------------------------------------------
    public string Visit (If node){
      return "";
    }
    //-----------------------------------------------------------
    public string Visit (Return node) {
      return Visit ((dynamic) node[0]) +
        "\t\treturn\n";
    }

    //-----------------------------------------------------------
    public string Visit (Identifier node) {
      var varName = node.AnchorToken.Lexeme;
      if (TempLocalSymbolTable != null && TempLocalSymbolTable.Contains (varName)) {
        if (inVariableDefinition)
          return $"    (local ${varName} i32)\n";
      } else if (GlobalVariables.Contains (varName) && !inStatement) {
        //Found a GlobalVariable, but this logic was already processed
        return "";
      } else if (GlobalVariables.Contains (varName)) {
        return $"\t\tglobal.get ${varName}\n";
      }
      return $"\t\tlocal.get ${varName}\n";
    }
    //-----------------------------------------------------------
    public string Visit (IntLiteral node) {
      return $"    i32.const {node.AnchorToken.Lexeme}\n";
    }
    //-----------------------------------------------------------
    public string Visit (True node) {
      return "    i32.const 1\n";
    }
    //-----------------------------------------------------------
    public string Visit (False node) {
      return "    i32.const 0\n";
    }
    //-----------------------------------------------------------
    public string Visit (And node) {
      return VisitBinaryOperator ("i32.and", node);
    }
    //-----------------------------------------------------------
    public string Visit (LessThan node) {
      return VisitBinaryOperator ("i32.lt_s", node);
    }
    //-----------------------------------------------------------
    public string Visit (Plus node) {
      return VisitBinaryOperator ("i32.add", node);
    }
    //-----------------------------------------------------------
    public string Visit (Times node) {
      return VisitBinaryOperator ("i32.mul", node);
    }
    //-----------------------------------------------------------
    public string Visit (StringLiteral node) {
      var lexeme = node.AnchorToken.Lexeme; // "ABC\n"
      var lexemeArr = AsCodePoint (lexeme); //[65, 66, 67, 10];
      return ListToWat (lexemeArr as List<dynamic>);
    }
    //t = ["ABC\n", 20, 'c']

    public string Visit (Array node) {
      var newArr = new List<dynamic> ();
      foreach (var child in node) {
        if (child is StringLiteral) {
          newArr.Add (AsCodePoint (child.AnchorToken.Lexeme));
        } else {
          newArr.Add (child.AnchorToken.Lexeme);
        }
      }
      return ListToWat (newArr); //
    }

    public string ListToWat (IList<dynamic> array) {
      var t = Generatelabel ();
      var sb = $"    i32.const 0\n" +
        "     call $new\n" +
        $"     local.set ${t}\n";
      foreach (var item in array) {
        sb += $"    local.get {t}\n" +
          $"    i32.const {item}\n" +
          "     call $add";
      }
      sb += $"     local.get {t}\n";
      return sb;
    }

    //-----------------------------------------------------------
    string VisitChildren (Node node) {
      var sb = new StringBuilder ();
      foreach (var n in node) {
        sb.Append (Visit ((dynamic) n));
      }
      return sb.ToString ();
    }

    //-----------------------------------------------------------
    string VisitBinaryOperator (string op, Node node) {
      return Visit ((dynamic) node[0]) +
        Visit ((dynamic) node[1]) +
        $"    {op}\n";
    }
  }
}